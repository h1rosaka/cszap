p478- 670(4.16)

1h
16:15 530
16:30 578
17:00 670

 4,6  b4.11



PC(プログラムカウンタ)を4くり上げる話
- PCに入っているのは命令のメモリアドレス 
- MIPSは全ての命令が整数同様に32bitだから、整数の時と同じように4バイト(=32bit)の倍数から始まるところに入ってる


図4.1
命令メモリ→メモリ自体というよりは、メモリアクセスをするための回路

マルチプレクサ
    入力が複数あって、どれを出力にするか
    図4.2のmux
    命令メモリの上のmux
        ジャンプするなら２段階加算した方の値を
        ジャンプしないなら4足しただけの値をPCに入れる
        どっちにするかをmuxで決めてる
        制御のところからのa==bならjumpみたいな条件を受け取ってる

regwrite
    レジスタに書き込みますか、しませんか
    レジスタに書き込まなくて良い命令がある
    regwriteが0なら書き込まない
    メモリに書き込みますよ、とかいう命令ならレジスタには書かない

    使うか使わないか、という情報を送るのは？
        半導体の中に、全ての機能をやる
        ALUには足し算引き算掛け算割り算の回路全てが入ってて、全部計算して、muxが今回は足し算の結果だけ使います、という形で使ってる
        メモリやレジスタに書き込む回路も全部やってしまうと、無駄な作業だし、必要ないもの書き込んで後に残って混乱するので、その回路は使わないで、という情報を送る必要がある。
        ALUの結果は残らないから、別にやってしまっても問題ない

RISC CISC
    Reduced instruction
        命令セットが少ないから、シンプルで色々最適化/高速化できていいよね
        CISCはRISCができてから、あれは古いcomplexなやつだよね~という悪口的に作られた単語
        intelより先に1Ghzを達成した
        結局昔のプログラムが使える、という点からx86が強いままだった
        windowsとintelの蜜月関係でシェア取れない
        RISCの良いところ取り入れて、CISCの
        MISPはインテルに喧嘩売るために作ったようなもの


遅延分岐
    - ループの次のやつも実行する
    - jumpするかどうかわからないから、次の命令実行できませんだと遅いので、次のやつやってから、jump元に戻る
    - jumpがeに依存しないなら、eを後にしてもいいよね
    ![alt text](image.png)
    - 現代のCPUではあまり採用されない

複数クロック
    - シングルクロック方式だと、データパスが一番長いところがボトルネックになって、一番長いパスによってCPU周波数が決まってしまう
    - 長いものは何クロックかかけてやるようにしましょうよ、というもの



OSのコンテキストスイッチの話とパイプライン
    - コンテキストスイッチは4ms　1/250秒ごと
    - 一方、パイプラインの図4.25のAにかかる時間は0.3ns(3Ghz)なので、1/30億　秒
    - パイプラインが大量に並んだものを処理して、その後コンテキストスイッチするイメージ


1clock
    - 回路の1番長いところを通るのにかかる時間
    - 図中の資格は記憶素子の集まり(フリップフロップ)
    - Aの計算を答えが出てから記憶し直すのではなく、途中結果メモするような回路にしておくと、パイプライン的にできていいよね、という話
    ![alt text](image-1.png)
    - もしやる仕事が決まってるなら、分割したほうが早くなる
        - 洗濯乾燥して、突然染み抜きが入るパターンが入る、とか、急にこれやって、とかあると、パイプラインの気持ちでやっても、理想通りのスピードにならない、むしろ余計なことして遅くなるとかもある。(途中のメモも0秒ではない)


構造ハザード
どうやって2倍速で128byte持ってくるか
メモリ二本差し
https://wa3.i-3-i.info/word15903.html
![alt text](image-2.png)
セマフォとかの話は、メモリからとってきたデータに複数のコアが同時にアクセスしないようにするもの。違う話。

4.7
五個のステージに分けて、途中結果をメモにかこう
メモをIF/IDとか呼ぼう


4.8

4.9
分岐命令があると、次の命令どっち実行したら良いのかわからんのでパイプラインができない　ストールする
何も計算しないで時間が過ぎる
分岐命令の後何クロックも無駄にするのはもったいないので、とりあえずやってみる
もしif文の結果が逆だったら、今やり始めてたの止めて、if文の後からやり直す。
当たってたら早くなる
当たらないと辛い
できるだけ当てるためのテクニック
過去の事例を用意しておくとか

分岐遅延は最近はあまり使われていない
分岐予測をハードウェアで作ったNNで当てに行ったりしてる
分岐遅延スロットを有効に使うには、安全かつ意味のある命令をスロットに入れなければならない。

これは非常に難しく、正確な依存関係解析と最適化が必要。

MIPSアーキテクチャでは、条件分岐命令を実行しても、次の1命令（=1スロット分）は必ず実行されるという設計になっています。この「必ず実行される1命令分の場所」が「分岐遅延スロット（branch delay slot）」です。
MIPSでは性能最適化のために、スロットに意味のある命令を入れるようコンパイラや人手で工夫されていました。
昔のMIPS用コンパイラ（例：GCC for MIPS）は、
安全で意味のある命令をスロットに配置する最適化（delay slot scheduling）をしていました。
それができない場合は NOP(何もしない) を挿入。



4.10
例外が起きると、8000 0000とかのメモリをPCが指すようになる
このアドレスを見に行って、セグメント不在とか別の例がが起きることをダブルフォルトという
https://os.phil-opp.com/ja/double-fault-exceptions/


4.11
1クロックに2命令以上実行したい
依存関係が発生するので、投機実行


プロセッサは機械語を爆速で処理したい
機械語のセットを定義しているのはプロセッサ作ってるのと同じ人
洗濯の実行に最適化された回路を作るのはこれが理由
要復習: addとかの命令と、図4.52とかの関係



アウトオブオーダー実行
これとこれは依存があるので、実行できないが、一個先のこれならいける、という時






